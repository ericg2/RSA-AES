/*
 *  RSA/AES KEY GENERATOR
 *  BY: HOUSEOFKRAFT
 *
 *  10/07/2020
 *
 *  Copyright (c) 2020 houseofkraft
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 *  to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 *  and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import java.util.Base64;
import java.math.*;
import java.net.*; 
import javax.crypto.*;
import javax.crypto.spec.*;
import java.security.*;
import java.io.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.lang.Exception;

import java.security.interfaces.*;
import java.security.spec.RSAPublicKeySpec;
import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.InvalidKeySpecException;

import java.nio.charset.StandardCharsets;

import java.lang.Math;

import java.util.Arrays;


public class RSA {

    public KeyPair rsaKeys;
    public KeyPairGenerator keyGen;
    private static SecretKeySpec aesSecretKey;
    private static byte[] key;
    public String aesPassword;
    public int aesSize;

    private PrivateKey privateKey;
    private PublicKey publicKey;
    public boolean aesEnabled;
    public boolean autoGenerated;

    /** 
     * If the autoGenerated param is set to true, this function will automatically generate a RSA key and
     * the random AES password to go along with it and set it into variables.
     *
     * Example Usage:
     * RSA rsaHandler = new RSA(true, 1024, 128);
     * String textToEncrypt = "Hello World!";
     * 
     * String encryptedText = rsaHandler.encrypt(textToEncrypt);
     * String decryptedText = rsaHandler.decrypt(encryptedText);
     *
     * System.out.println(decryptedText);
     *
     * @param autoGenerated if the RSA key and AES password should be auto-geneerated or entered manually.
     * @param keySize the size of the RSA key in bits
     * @param aesSize the size of the auto-generated AES password
     */
    public RSA(boolean autoGenerated, int keySize, int aesSize) throws Exception {

        boolean aesEnabled = true;

        if (autoGenerated) {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
            keyGen.initialize(keySize, new SecureRandom());

            KeyPair rsaKeys = keyGen.generateKeyPair(); 
            
            if (aesEnabled) {
                String aesPassword = generatePassword(aesSize);
                this.aesPassword = aesPassword;

                // set the secret key when the password is generated.
                setAESKey(this.aesPassword);
            }

            this.rsaKeys = rsaKeys;  
            this.aesSize = aesSize;  
            this.autoGenerated = autoGenerated;

            privateKey = rsaKeys.getPrivate();
            publicKey = rsaKeys.getPublic();
     
        } 
    }

    public PrivateKey getPrivateKey() {
        return privateKey;
    } 

    public PublicKey getPublicKey() {
        return publicKey;
    }

    public String getAESKey() {
        return this.aesPassword;
    }

    /**
     * Sets the AES password manually when not auto-generating
     * @param aesPass AES password
     */
    public void setAESKey(String aesPass) throws Exception {

        MessageDigest sha = null;
        key = aesPass.getBytes("UTF-8");
        sha = MessageDigest.getInstance("SHA-1");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16); 
        aesSecretKey = new SecretKeySpec(key, "AES");

        this.aesSecretKey = aesSecretKey;
    }

    /**
     * Sets the Private Key manually when not auto-generating
     * @param key64 Private Key
     */
    public void setPrivateKey(String key64) throws Exception {
        byte[] clear = Base64.getDecoder().decode(key64.getBytes());
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(clear);

        KeyFactory factPr = KeyFactory.getInstance("RSA");
        PrivateKey priv = factPr.generatePrivate(keySpec);
        Arrays.fill(clear, (byte) 0);
        
        privateKey = priv;
    }

    /**
     * Sets the Public Key manually when not auto-generating
     * @param pubKey Public Key
     */
    public void setPublicKey(String pubKey) throws Exception {
        byte[] data = Base64.getDecoder().decode((pubKey.getBytes()));

        X509EncodedKeySpec spec = new X509EncodedKeySpec(data);
        KeyFactory factP = KeyFactory.getInstance("RSA");
        
        publicKey = factP.generatePublic(spec);
    }

    /**
     * Automatically generate a password by cycling through a string of random
     * characters and adding it on
     * @param passwordLength the length in characters the password should be
     */
    private String generatePassword(int passwordLength) throws Exception {

        String characters = "`1234567890-=qwertyuiop[]asdfghjkl;'zxcvbnm,./~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:ZXCVBNM<>?";
        String finalPassword = "";

        // do the math operation here instead of the for loop for efficency reasons.
        int charLength = characters.length() - 1;

        for (int i = 0; i < passwordLength; ++i) {
            finalPassword = finalPassword + characters.charAt(getRandomNumber(0,charLength));
        }

        return finalPassword;
    }

    /**
     * Encrypts the given plaintext string with RSA. This should not
     * be used and the regular "encrypt" function should be used instead.
     *
     * @param plainText the text to encrypt
     */
    private String rawRSAEncrypt(String plainText) throws Exception {

        Cipher encryptCipher = Cipher.getInstance("RSA");
        encryptCipher.init(Cipher.ENCRYPT_MODE, getPublicKey());

        byte[] cipherText = encryptCipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));

        return Base64.getEncoder().encodeToString(cipherText);
    }

    /**
     * Decrypts the given cipher string with RSA. This should not
     * be used and the regular "decrypt" function should be used instead.
     *
     * @param cipherText the cipher to decrypt
     */
    private String rawRSADecrypt(String cipherText) throws Exception {
        byte[] bytes = Base64.getDecoder().decode(cipherText);

        Cipher decriptCipher = Cipher.getInstance("RSA");
        decriptCipher.init(Cipher.DECRYPT_MODE, getPrivateKey());

        return new String(decriptCipher.doFinal(bytes), StandardCharsets.UTF_8);
    }

    /**
     * Generates a random number, used for some functions that
     * require it.
     *
     * @param min the minimum number 
     * @param max the maximum number
     */
    private int getRandomNumber(int min, int max) {
        return (int) ((Math.random() * (max - min)) + min);
    }

    /**
     * Encrypts plaintext using RSA and then encrypts it with AES for 
     * double protection.
     *
     * @param plainText the text to encrypt
     */
    public String encrypt(String plainText) throws Exception {
        String rsaEncrypted = rawRSAEncrypt(plainText);

        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, this.aesSecretKey);
        return Base64.getEncoder().encodeToString(cipher.doFinal(rsaEncrypted.getBytes("UTF-8")));
    }

    /**
     * Decrypts the text
     *
     * @param plainText the text to encrypt
     */
    public String decrypt(String encryptedText) throws Exception {

        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5PADDING");
        cipher.init(Cipher.DECRYPT_MODE, this.aesSecretKey);
        
        String aesDecrypted = new String(cipher.doFinal(Base64.getDecoder().decode(encryptedText)));
        String rsaDecrypted = rawRSADecrypt(aesDecrypted);

        return rsaDecrypted;
    }
}
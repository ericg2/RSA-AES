/*
 *  RSA/AES KEY GENERATOR V2
 *  BY: HOUSEOFKRAFT
 *
 *  LAST MODIFIED: 11/2/2020
 *
 *  Copyright (c) 2020 houseofkraft
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import java.util.Base64;
import javax.crypto.*;
import javax.crypto.spec.*;
import java.io.*;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.lang.Exception;

import java.nio.charset.StandardCharsets;
import java.lang.Math;
import java.util.Arrays;
import java.util.Scanner;


public class RSA {

    public KeyPair rsaKeys;
    private static SecretKeySpec aesSecretKey;
    private static byte[] key;
    public String aesPassword;
    public int aesSize;
    private MessageDigest sha;

    private PrivateKey privateKey;
    private PublicKey publicKey;
    public boolean autoGenerated;

    /**
     * If the autoGenerated param is set to true, this function will automatically generate a RSA key and
     * the random AES password to go along with it and set it into variables.
     *
     * Example Usage:
     * RSA rsaHandler = new RSA(true, 1024, 128);
     * String textToEncrypt = "Hello World!";
     *
     * String encryptedText = rsaHandler.encrypt(textToEncrypt);
     * String decryptedText = rsaHandler.decrypt(encryptedText);
     *
     * System.out.println(decryptedText);
     *
     * @param autoGenerated if the RSA key and AES password should be auto-generated or entered manually.
     * @param keySize the size of the RSA key in bits
     * @param aesSize the size of the auto-generated AES password
     */
    public RSA(boolean autoGenerated, int keySize, int aesSize) throws Exception {

        if (autoGenerated) {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
            keyGen.initialize(keySize, new SecureRandom());

            KeyPair rsaKeys = keyGen.generateKeyPair();

            this.aesPassword = generatePassword(aesSize);

            // set the secret key when the password is generated.
            setAESKey(this.aesPassword);

            this.rsaKeys = rsaKeys;
            this.aesSize = aesSize;
            this.autoGenerated = true;

            privateKey = rsaKeys.getPrivate();
            publicKey = rsaKeys.getPublic();

        }
    }

    // These three functions are pretty self-explanatory ;)
    public PrivateKey getPrivateKey() {
        return privateKey;
    }

    public String getPrivateKeyString() {
        return Base64.getEncoder().encodeToString(getPrivateKey().getEncoded());
    }

    public String getPublicKeyString() {
        return Base64.getEncoder().encodeToString(getPublicKey().getEncoded());
    }

    public String getAESKeyString() { return getAESKey(); }

    public PublicKey getPublicKey() {
        return publicKey;
    }

    public String getAESKey() {
        return this.aesPassword;
    }

    /**
     * Sets the AES password manually when not auto-generating
     * @param aesPass AES password
     */
    public void setAESKey(String aesPass) throws Exception {
        key = aesPass.getBytes(StandardCharsets.UTF_8);
        sha = MessageDigest.getInstance("SHA-1");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16);

        this.aesSecretKey = new SecretKeySpec(key, "AES");
    }

    /**
     * Sets the Private Key manually when not auto-generating
     * @param key64 Private Key
     */
    public void setPrivateKey(String key64) throws Exception {
        byte[] clear = Base64.getDecoder().decode(key64.getBytes());
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(clear);

        KeyFactory factPr = KeyFactory.getInstance("RSA");
        PrivateKey priv = factPr.generatePrivate(keySpec);
        Arrays.fill(clear, (byte) 0);

        privateKey = priv;
    }

    /**
     * Sets the Public Key manually when not auto-generating
     * @param pubKey Public Key
     */
    public void setPublicKey(String pubKey) throws Exception {
        byte[] data = Base64.getDecoder().decode((pubKey.getBytes()));

        X509EncodedKeySpec spec = new X509EncodedKeySpec(data);
        KeyFactory factP = KeyFactory.getInstance("RSA");

        publicKey = factP.generatePublic(spec);
    }

    /**
     * Automatically generate a password by cycling through a string of random
     * characters and adding it on
     * @param passwordLength the length in characters the password should be
     */
    private String generatePassword(int passwordLength) {

        String characters = "`1234567890-=qwertyuiop[]asdfghjkl;'zxcvbnm,./~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:ZXCVBNM<>?";
        StringBuilder finalPassword = new StringBuilder();

        // Do the math operation here instead of the for loop for efficiency reasons.
        int charLength = characters.length() - 1;

        for (int i = 0; i < passwordLength; ++i) {
            finalPassword.append(characters.charAt(getRandomNumber(0, charLength)));
        }

        return finalPassword.toString();
    }

    /**
     * Encrypts the given plaintext string with RSA. This should not
     * be used and the regular "encrypt" function should be used instead.
     *
     * @param plainText the text to encrypt
     */
    private String rawRSAEncrypt(String plainText) throws Exception {

        Cipher encryptCipher = Cipher.getInstance("RSA");
        encryptCipher.init(Cipher.ENCRYPT_MODE, getPublicKey());

        byte[] cipherText = encryptCipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));

        return Base64.getEncoder().encodeToString(cipherText);
    }

    /**
     * Decrypts the given cipher string with RSA. This should not
     * be used and the regular "decrypt" function should be used instead.
     *
     * @param cipherText the cipher to decrypt
     */
    private String rawRSADecrypt(String cipherText) throws Exception {
        byte[] bytes = Base64.getDecoder().decode(cipherText);

        Cipher decryptCipher = Cipher.getInstance("RSA");
        decryptCipher.init(Cipher.DECRYPT_MODE, getPrivateKey());

        return new String(decryptCipher.doFinal(bytes), StandardCharsets.UTF_8);
    }

    /**
     * Generates a random number, used for some functions that
     * require it.
     *
     * @param min the minimum number 
     * @param max the maximum number
     */
    private int getRandomNumber(int min, int max) {
        return (int) ((Math.random() * (max - min)) + min);
    }

    /**
     * Encrypts plaintext using RSA and then encrypts it with AES for 
     * double protection.
     *
     * @param plainText the text to encrypt
     */
    public String encrypt(String plainText) throws Exception {
        String rsaEncrypted = rawRSAEncrypt(plainText);

        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, this.aesSecretKey);
        return Base64.getEncoder().encodeToString(cipher.doFinal(rsaEncrypted.getBytes(StandardCharsets.UTF_8)));
    }

    private SecretKeySpec convertToAESKey(String convertText) throws Exception {
        key = convertText.getBytes(StandardCharsets.UTF_8);
        sha = MessageDigest.getInstance("SHA-1");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16);

        return new SecretKeySpec(key, "AES");
    }

    private String rawAESEncrypt(String plainText, String password) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, convertToAESKey(password));

        return Base64.getEncoder().encodeToString(cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8)));
    }

    private String rawAESDecrypt(String cipherText, String decryptPassword) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, convertToAESKey(decryptPassword));

        return new String(cipher.doFinal(Base64.getDecoder().decode(cipherText)));
    }

    private void writeToFile(String fileName, String fileText) throws Exception {
        PrintWriter fileWriter = new PrintWriter(fileName);

        fileWriter.println(fileText);
        fileWriter.close();
    }

    /**
     * Decrypts the text
     *
     * @param encryptedText the text to decrypt
     */
    public String decrypt(String encryptedText) throws Exception {

        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5PADDING");
        cipher.init(Cipher.DECRYPT_MODE, this.aesSecretKey);

        String aesDecrypted = new String(cipher.doFinal(Base64.getDecoder().decode(encryptedText)));
        return rawRSADecrypt(aesDecrypted);
    }

    /**
     * Generates a file containing all of the keys, This can be used for loading
     * keys in software or transmissions easily.
     *
     * @param fileOutput where the file should go
     */
    public void generateKeyFile(String fileOutput) throws Exception {
        String keyFileData = getPublicKeyString() + "§" + getPrivateKeyString() + "§" + this.aesPassword;
        writeToFile(fileOutput, keyFileData);
    }

    /**
     * Loads a generated keyfile into the required keys used for encrypting
     * and decrypting information easily.
     *
     * @param fileInput where the file is located
     */
    public void loadKeyFile(String fileInput) throws Exception {
        File fileObj = new File(fileInput);
        Scanner fileReader = new Scanner(fileObj);

        StringBuilder fileText = new StringBuilder();

        while (fileReader.hasNextLine()) {
            String fileData = fileReader.nextLine();
            fileText.append(fileData);
        }

        String[] decryptionKeys = fileText.toString().split("§");
        String tempPublicKey = decryptionKeys[0];
        String tempPrivateKey = decryptionKeys[1];
        String tempAESKey = decryptionKeys[2];
        
        setPublicKey(tempPublicKey);
        setPrivateKey(tempPrivateKey);
        setAESKey(tempAESKey);
    }
}
